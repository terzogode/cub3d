FLUSSO DEL PROGRAMMA (cartella bonus) - VERSIONE DETTAGLIATA
=============================================================

0) OBIETTIVO DEL DOCUMENTO
- Spiegare il flusso reale del programma in ordine di esecuzione.
- Per ogni funzione: cosa fa, perché fa quei calcoli e con quale logica.
- Evito dettagli banali tipo “i++ itera”, ma spiego i calcoli importanti.




1) AVVIO (main.c)
1.1 Controllo input
- validate_input(ac, av): verifica che il numero di argomenti sia corretto e che
  il file passato sia un .cub valido.

1.2 Inizializzazione strutture base
- struct_init(&g): alloca e inizializza TUTTE le strutture principali
  PATTERN: allocazione (10 campi) → validazione → helper initialization
  ✓ ALLOCAZIONE: map, player, floor, wall, ceiling, tex_north/south/west/east, parse
  ✓ VALIDAZIONE: single check su tutti i puntatori, return(1) se fail
  ✓ HELPER: initialize_door_system + initialize_mlx_fields se OK
  Usa le funzioni initialize_* (più sicure di ft_calloc):
  - initialize_map/player/color/texture/parse: valori espliciti controllati
  - initialize_mlx_fields: imposta width/height, perf system (last_ms, fps, fps_raw, last_draw_ms), show_fps
  ⚠️ Se allocazione fallisce: return(1) → main.c chiama cleanup_game_fields(&g) per risorsa parziale

1.3 Parsing del file .cub
- parse_file(&g, av[1]) esegue:
  a) load_file_to_parse: legge tutte le righe del file.
  b) find_map_start: individua dove inizia la mappa.
  c) parse_elements: legge texture (NO/SO/WE/EA) e colori (F/C).
  d) are_all_elements_set: controlla che tutti gli elementi obbligatori esistano.
  e) extract_map: estrae la griglia della mappa e la salva in game->map.

1.4 Validazione mappa
- validate_map(&g):
  a) validate_and_find_player: controlla caratteri validi e cerca il player.
     - Posiziona il player al centro della cella e converte N/S/E/W in direzione.
     - Sostituisce la cella del player con '0'.
  b) validate_map_borders: controlla che la mappa sia chiusa con un flood fill.

1.5 Inizializzazione gioco e grafica
- init_game(&g): crea buffer per distanza colonne (columns_distance array).
- init_mlx(&g): inizializza MLX, finestra (1920x1080), immagine e buffer schermo.
- init_textures(&g): carica le 4 texture pareti (N/S/W/E) + le 4 texture porta.
- init_doors: analizza la mappa ('D' = porta) e registra le porte con stato/animazione.

1.6 Hook eventi
- mlx_hook: associa funzioni ai tasti, mouse e chiusura finestra.
- mlx_loop_hook: chiama loop_hook ad ogni frame.
- mlx_loop: entra nel ciclo principale MLX.


2) INPUT E MOVIMENTO (key_management.c, key_utils.c, move_management.c, rotation.c, mouse_management.c)
2.1 Input tastiera
- key_press:
  - WASD: setta i flag di movimento.
  - Q/E o frecce: setta i flag di rotazione.
  - F: tenta di aprire/chiudere una porta vicina.
  - M: attiva/disattiva il mouse.
  - ESC: chiude il gioco.
- key_release: rilascia i flag di movimento e rotazione.

2.2 Movimento
- update_player_position:
  - Se i flag sono attivi, muove il player in avanti/indietro/laterale.
  - try_move_x / try_move_y: controlla collisioni con muri ('1') o porte ('D').
  - Se la porta è aperta, il player può passarci.

2.3 Rotazione
- update_player_rotation: ruota direzione e piano di camera.
- mouse_move: usa il movimento del mouse per ruotare la visuale.


3) CICLO PRINCIPALE (main_rendering.c)
Ad ogni frame, loop_hook esegue:
1) perf_update: aggiorna il tempo per calcolare delta_time.
2) update_door_animations: anima le porte in base allo stato aperta/chiusa.
3) rendering: disegna tutto.
4) mlx_put_image_to_window: mostra il frame.
5) draw_fps_overlay se richiesto.


4) RENDERING (main_rendering.c, draw.c)
4.1 Preparazione
- Pulisce lo schermo (buffer pixel).
- Aggiorna posizione e rotazione del player.

4.2 Ray casting (sezione speciale sotto)
- Per ogni colonna dello schermo:
  - cast_one_ray calcola dove il raggio colpisce un muro o una porta chiusa.
  - calcola la distanza dal muro.
  - disegna la colonna con texture e ombre.

4.3 Disegno cielo e pavimento
- draw_ceiling_part / draw_floor_part: colorano cielo e pavimento con ombre.

4.4 Minimap e FPS
- draw_minimap: disegna mappa e player in alto.
- draw_fps_overlay: mostra FPS se attivo.


5) PORTE (doors.c, utils.c, texture.c)
- Le porte sono segnate con 'D' nella mappa.
- init_doors crea una lista di porte con stato (aperta/chiusa) e animazione.
- update_door_animations:
  - Se la porta è aperta, l’animazione sale verso 1.0.
  - Se è chiusa, scende verso 0.0.
- get_door_frame_texture: sceglie il frame giusto in base all’animazione.
- check_and_toggle_door: quando premi F, cerca porte vicine e cambia stato.


6) RAY CASTING SPIEGATO SEMPLICE (per bambini)
Immagina che il player abbia tanti “occhietti” o “lampadine” davanti a sé.
Ogni lampadina guarda in una direzione leggermente diversa. Sono i raggi.

Ecco cosa succede per ogni colonna dello schermo:
1) Il programma decide la direzione del raggio.
   È come scegliere dove guarda una lampadina.
2) Il raggio avanza a piccoli passi in una griglia fatta di quadrati.
   Ogni quadrato può essere:
   - muro ('1')
   - spazio vuoto ('0')
   - porta ('D')
3) Appena il raggio tocca un muro, si ferma.
   Se tocca una porta chiusa, si ferma anche lì.
   Se la porta è aperta, il raggio può passare.
4) Quando si ferma, il programma misura “quanto è lontano”.
   Più lontano = muro più piccolo sullo schermo.
5) Con questa distanza, disegna una striscia verticale (una colonna):
   - se il muro è vicino, la striscia è alta;
   - se è lontano, la striscia è bassa.
6) Poi mette sopra la texture giusta, come attaccare un disegno sul muro.

È come se avessimo un robot che, per ogni striscia dello schermo, lancia
una “bolla magica” che va dritta finché sbatte contro un muro o una porta.
Quando sbatte, il robot disegna quel punto sullo schermo.
Così, tante strisce una accanto all’altra, formano l’immagine 3D.


7) USCITA E PULIZIA
- Quando chiudi la finestra o premi ESC, clean_up libera memoria e chiude MLX.


FINE